#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2021 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
from __future__ import print_function
import sys
import argparse
import rapidtide.io as tide_io
import rapidtide.miscmath as tide_math
import rapidtide.workflows.parser_funcs as pf

import numpy as np


def summarize(thevoxels, method="mean"):
    theshape = thevoxels.shape
    if len(theshape) > 1:
        numtimepoints = theshape[1]
    else:
        numtimepoints = 1

    if method == "mean":
        themethod = np.mean
    elif method == "median":
        themethod = np.median
    else:
        print("illegal summary method in summarize")
        sys.exit()
    if numtimepoints > 1:
        regionsummary = np.nan_to_num(themethod(thevoxels, axis=1))
    else:
        regionsummary = np.nan_to_num(themethod(thevoxels))
    return regionsummary


def _get_parser():
    # get the command line parameters
    parser = argparse.ArgumentParser(
        prog="atlasaverage",
        description="Average data within atlas regions.",
        usage="%(prog)s datafile templatefile outputfile [options]",
    )
    parser.add_argument(
        "datafile",
        type=lambda x: pf.is_valid_file(parser, x),
        help="The name of the 3 or 4D nifti file with the data to be averaged over atlas regions.",
    )
    parser.add_argument(
        "templatefile",
        type=lambda x: pf.is_valid_file(parser, x),
        help="The name of the atlas region NIFTI file",
    )
    parser.add_argument("outputfile", help="The name of the output NIFTI file.")

    # add optional arguments
    parser.add_argument(
        "--normmethod",
        dest="normmethod",
        action="store",
        type=str,
        choices=["none", "pct", "var", "std", "p2p"],
        help=(
            "Normalization to apply to input timecourses. Choices are "
            "are 'none' (no normalization, default), 'pct' (divide by mean, set mean to zero), "
            "'var' (unit variance, zero mean), 'std' (unit standard deviation, zero mean), "
            "'p2p' (unit range, zero mean)."
        ),
        default=None,
    )
    parser.add_argument(
        "--summarymethod",
        dest="summarymethod",
        action="store",
        type=str,
        choices=["mean", "median"],
        help=("Method to summarize a region.  Choices are 'mean' (default), and 'median'."),
        default=None,
    )

    return parser


def main():
    # get the command line parameters
    try:
        args = _get_parser().parse_args()
    except SystemExit:
        _get_parser().print_help()
        raise

    if args.normmethod == "none":
        print("will not normalize timecourses")
    elif args.normmethod == "pct":
        print("will normalize timecourses to percentage of mean")
    elif args.normmethod == "std":
        print("will normalize timecourses to standard deviation of 1.0")
    elif args.normmethod == "var":
        print("will normalize timecourses to variance of 1.0")
    elif args.normmethod == "p2p":
        print("will normalize timecourses to p-p deviation of 1.0")

    print("loading fmri data")
    input_img, input_data, input_hdr, thedims, thesizes = tide_io.readfromnifti(args.datafile)
    print("loading template data")
    (
        template_img,
        template_data,
        template_hdr,
        templatedims,
        templatesizes,
    ) = tide_io.readfromnifti(args.templatefile)

    print("checking dimensions")
    if not tide_io.checkspacematch(input_hdr, template_hdr):
        print("template file does not match spatial coverage of input fmri file")
        sys.exit()

    print("reshaping")
    xsize = thedims[1]
    ysize = thedims[2]
    numslices = thedims[3]
    numtimepoints = thedims[4]
    numvoxels = int(xsize) * int(ysize) * int(numslices)
    templatevoxels = np.reshape(template_data, numvoxels).astype(int)
    inputvoxels = np.reshape(input_data, (numvoxels, numtimepoints))
    numregions = np.max(templatevoxels)
    timecourses = np.zeros((numregions, numtimepoints), dtype="float")

    if numtimepoints > 1:
        for theregion in range(1, numregions + 1):
            thevoxels = inputvoxels[np.where(templatevoxels == theregion), :]
            print(
                "extracting",
                thevoxels.shape[1],
                "voxels from region",
                theregion,
                "of",
                numregions,
            )
            if thevoxels.shape[1] > 0:
                # regiontimecourse = np.nan_to_num(np.mean(thevoxels, axis=1))
                regiontimecourse = summarize(thevoxels, method=args.summarymethod)
            else:
                regiontimecourse = timecourses[0, :] * 0.0
            if args.normmethod == "none":
                timecourses[theregion - 1, :] = regiontimecourse - np.mean(regiontimecourse)
            elif args.normmethod == "pct":
                timecourses[theregion - 1, :] = tide_math.pcnormalize(regiontimecourse)
            elif args.normmethod == "var":
                timecourses[theregion - 1, :] = tide_math.varnormalize(regiontimecourse)
            elif args.normmethod == "std":
                timecourses[theregion - 1, :] = tide_math.stdnormalize(regiontimecourse)
            elif args.normmethod == "p2p":
                timecourses[theregion - 1, :] = tide_math.ppnormalize(regiontimecourse)
            else:
                print("illegal normalization method")
                _get_parser().print_help()
                raise
        tide_io.writenpvecs(timecourses, args.outputfile)
    else:
        outputvoxels = np.reshape(input_data, (numvoxels, numtimepoints))
        for theregion in range(1, numregions + 1):
            thevoxels = inputvoxels[np.where(templatevoxels == theregion)]
            regionval = summarize(thevoxels, method=args.summarymethod)
            outputvoxels[np.where(templatevoxels == theregion)] = regionval
        template_hdr["dim"][4] = numregions
        tide_io.savetonifti(
            outputvoxels.reshape((xsize, ysize, numslices, numregions)),
            template_hdr,
            args.outputfile,
        )


if __name__ == "__main__":
    main()
