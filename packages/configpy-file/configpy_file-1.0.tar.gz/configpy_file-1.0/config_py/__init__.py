python_keywords = [
    'False',
    'None',
    'True',
    'and',
    'as',
    'assert',
    'async',
    'await',
    'break',
    'class',
    'continue',
    'def',
    'del',
    'elif',
    'else',
    'except',
    'finally',
    'for',
    'from',
    'global',
    'if',
    'import',
    'in',
    'is',
    'lambda',
    'nonlocal',
    'not',
    'or',
    'pass',
    'raise',
    'return',
    'try',
    'while',
    'with',
    'yield'
]

c_keywords = [
    'alignas',
    'alignof',
    'and',
    'and_eq',
    'asm',
    'atomic_cancel',
    'atomic_commit',
    'atomic_noexcept',
    'auto',
    'bitand',
    'bitor',
    'bool',
    'break',
    'case',
    'catch',
    'char',
    'char8_t',
    'char16_t',
    'char32_t',
    'class',
    'compl',
    'concept',
    'const',
    'consteval',
    'constexpr',
    'constinit',
    'const_cast',
    'continue',
    'co_await',
    'co_return',
    'co_yield',
    'decltype',
    'default',
    'delete',
    'do',
    'double',
    'dynamic_cast',
    'else',
    'enum',
    'explicit',
    'export',
    'extern',
    'false',
    'float',
    'for',
    'friend',
    'goto',
    'if',
    'inline',
    'int',
    'long',
    'mutable',
    'namespace',
    'new',
    'noexcept',
    'not',
    'not_eq',
    'nullptr',
    'operator',
    'or',
    'or_eq',
    'private',
    'protected',
    'public',
    'reflexpr',
    'register',
    'reinterpret_cast',
    'requires',
    'return',
    'short',
    'signed',
    'sizeof',
    'static',
    'static_assert',
    'static_cast',
    'struct',
    'switch',
    'synchronized',
    'template',
    'this',
    'thread_local',
    'throw',
    'true',
    'try',
    'typedef',
    'typeid',
    'typename',
    'union',
    'unsigned',
    'using',
    'virtual',
    'void',
    'volatile',
    'wchar_t',
    'while',
    'xor',
    'xor_eq',
]

keywords = python_keywords + c_keywords

allow_types = [
    'int',
    'str',
    'float',
    'bool',
    'NoneType'
]

def get_c_definition(name, value):
    type_ = value.__class__.__name__
    if type_ in ('int', 'bool'):
        return type_ + ' ' + name + ' = ' + str(value) + ';\n'
    if type_ == 'NoneType':
        return '// TODO: change type if needed\nint ' + name + ' = nullptr;\n'
    if type_ == 'float':
        return 'double ' + name + ' = '+ str(value) + ';\n'
    if type_ == 'str':
        if len(value) == 1:
            return 'char ' + name + " = '"+ value + "';\n"
    return 'char* ' + name + ' = "'+ value + '";\n'
    

class ConfigPy(dict):
    def __setitem__(self, itemname, value):
        if isinstance(itemname, bytes):
            itemname = itemname.decode()
        if not isinstance(itemname, str):
            raise TypeError(f"expected str-like object, not '{itemname.__class__.__name__}'")
        if itemname.isidentifier() and itemname not in keywords:
            if value.__class__.__name__ in allow_types:
                dict.__setitem__(self, itemname, value)
            else:
                raise TypeError(f"invalid type: '{value.__class__.__name__}'")
        else:
            raise TypeError(f"invalid python identifier: '{itemname}'")
    def save(self, file_name):
        import py_compile as c
        import os
        import time
        ext = os.path.basename(file_name).split('.')[-1]
        if ext in ('py', 'pyc'):
            code = '# Generated by config.py\n\n'
            for key in self.keys():
                code += key + ' = ' + str(self[key]) + '\n'
        elif ext in ('c', 'cpp', 'h', 'hpp'):
            code = '// Generated by config.py\n\n'
            for key in self.keys():
                code += get_c_definition(key, self[key])
        else:
            raise TypeError(f"invalid extension: '{ext}'")
        if ext == 'pyc':
            t = str(time.time())
            with open(file_name[:-1] + t, 'w') as f:
                f.write(code)
            c.compile(file_name[:-1] + t, file_name)
            os.remove(file_name[:-1] + t)
        else:
            with open(file_name, 'w') as f:
                f.write(code)

