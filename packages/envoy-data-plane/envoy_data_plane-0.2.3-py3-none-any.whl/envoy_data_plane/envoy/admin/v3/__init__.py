# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/admin/v3/mutex_stats.proto, envoy/admin/v3/init_dump.proto, envoy/admin/v3/listeners.proto, envoy/admin/v3/metrics.proto, envoy/admin/v3/server_info.proto, envoy/admin/v3/config_dump.proto, envoy/admin/v3/tap.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List

import betterproto


class SimpleMetricType(betterproto.Enum):
    COUNTER = 0
    GAUGE = 1


class ServerInfoState(betterproto.Enum):
    LIVE = 0
    DRAINING = 1
    PRE_INITIALIZING = 2
    INITIALIZING = 3


class CommandLineOptionsIpVersion(betterproto.Enum):
    v4 = 0
    v6 = 1


class CommandLineOptionsMode(betterproto.Enum):
    Serve = 0
    Validate = 1
    InitOnly = 2


class CommandLineOptionsDrainStrategy(betterproto.Enum):
    Gradual = 0
    Immediate = 1


@dataclass(eq=False, repr=False)
class MutexStats(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    num_contentions: int = betterproto.uint64_field(1)
    # The length of the current contention wait cycle.
    current_wait_cycles: int = betterproto.uint64_field(2)
    # The lifetime total of all contention wait cycles.
    lifetime_wait_cycles: int = betterproto.uint64_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UnreadyTargetsDumps(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    unready_targets_dumps: List[
        "UnreadyTargetsDumpsUnreadyTargetsDump"
    ] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UnreadyTargetsDumpsUnreadyTargetsDump(betterproto.Message):
    name: str = betterproto.string_field(1)
    target_names: List[str] = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Listeners(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    listener_statuses: List["ListenerStatus"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerStatus(betterproto.Message):
    name: str = betterproto.string_field(1)
    local_address: "__config_core_v3__.Address" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SimpleMetric(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    type: "SimpleMetricType" = betterproto.enum_field(1)
    # The length of the current contention wait cycle.
    value: int = betterproto.uint64_field(2)
    # The lifetime total of all contention wait cycles.
    name: str = betterproto.string_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ServerInfo(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    version: str = betterproto.string_field(1)
    # The length of the current contention wait cycle.
    state: "ServerInfoState" = betterproto.enum_field(2)
    # The lifetime total of all contention wait cycles.
    uptime_current_epoch: timedelta = betterproto.message_field(3)
    uptime_all_epochs: timedelta = betterproto.message_field(4)
    hot_restart_version: str = betterproto.string_field(5)
    command_line_options: "CommandLineOptions" = betterproto.message_field(6)
    node: "__config_core_v3__.Node" = betterproto.message_field(7)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CommandLineOptions(betterproto.Message):
    base_id: int = betterproto.uint64_field(1)
    use_dynamic_base_id: bool = betterproto.bool_field(31)
    base_id_path: str = betterproto.string_field(32)
    concurrency: int = betterproto.uint32_field(2)
    config_path: str = betterproto.string_field(3)
    config_yaml: str = betterproto.string_field(4)
    allow_unknown_static_fields: bool = betterproto.bool_field(5)
    reject_unknown_dynamic_fields: bool = betterproto.bool_field(26)
    ignore_unknown_dynamic_fields: bool = betterproto.bool_field(30)
    admin_address_path: str = betterproto.string_field(6)
    local_address_ip_version: "CommandLineOptionsIpVersion" = betterproto.enum_field(7)
    log_level: str = betterproto.string_field(8)
    component_log_level: str = betterproto.string_field(9)
    log_format: str = betterproto.string_field(10)
    log_format_escaped: bool = betterproto.bool_field(27)
    log_path: str = betterproto.string_field(11)
    service_cluster: str = betterproto.string_field(13)
    service_node: str = betterproto.string_field(14)
    service_zone: str = betterproto.string_field(15)
    file_flush_interval: timedelta = betterproto.message_field(16)
    drain_time: timedelta = betterproto.message_field(17)
    drain_strategy: "CommandLineOptionsDrainStrategy" = betterproto.enum_field(33)
    parent_shutdown_time: timedelta = betterproto.message_field(18)
    mode: "CommandLineOptionsMode" = betterproto.enum_field(19)
    disable_hot_restart: bool = betterproto.bool_field(22)
    enable_mutex_tracing: bool = betterproto.bool_field(23)
    restart_epoch: int = betterproto.uint32_field(24)
    cpuset_threads: bool = betterproto.bool_field(25)
    disabled_extensions: List[str] = betterproto.string_field(28)
    bootstrap_version: int = betterproto.uint32_field(29)
    enable_fine_grain_logging: bool = betterproto.bool_field(34)
    socket_path: str = betterproto.string_field(35)
    socket_mode: int = betterproto.uint32_field(36)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ConfigDump(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    configs: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateFailureState(betterproto.Message):
    failed_configuration: "betterproto_lib_google_protobuf.Any" = (
        betterproto.message_field(1)
    )
    last_update_attempt: datetime = betterproto.message_field(2)
    details: str = betterproto.string_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class BootstrapConfigDump(betterproto.Message):
    bootstrap: "__config_bootstrap_v3__.Bootstrap" = betterproto.message_field(1)
    last_updated: datetime = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenersConfigDump(betterproto.Message):
    version_info: str = betterproto.string_field(1)
    static_listeners: List[
        "ListenersConfigDumpStaticListener"
    ] = betterproto.message_field(2)
    dynamic_listeners: List[
        "ListenersConfigDumpDynamicListener"
    ] = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenersConfigDumpStaticListener(betterproto.Message):
    listener: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)
    last_updated: datetime = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenersConfigDumpDynamicListenerState(betterproto.Message):
    version_info: str = betterproto.string_field(1)
    listener: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    last_updated: datetime = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenersConfigDumpDynamicListener(betterproto.Message):
    name: str = betterproto.string_field(1)
    active_state: "ListenersConfigDumpDynamicListenerState" = betterproto.message_field(
        2
    )
    warming_state: "ListenersConfigDumpDynamicListenerState" = (
        betterproto.message_field(3)
    )
    draining_state: "ListenersConfigDumpDynamicListenerState" = (
        betterproto.message_field(4)
    )
    error_state: "UpdateFailureState" = betterproto.message_field(5)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClustersConfigDump(betterproto.Message):
    version_info: str = betterproto.string_field(1)
    static_clusters: List[
        "ClustersConfigDumpStaticCluster"
    ] = betterproto.message_field(2)
    dynamic_active_clusters: List[
        "ClustersConfigDumpDynamicCluster"
    ] = betterproto.message_field(3)
    dynamic_warming_clusters: List[
        "ClustersConfigDumpDynamicCluster"
    ] = betterproto.message_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClustersConfigDumpStaticCluster(betterproto.Message):
    cluster: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)
    last_updated: datetime = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClustersConfigDumpDynamicCluster(betterproto.Message):
    version_info: str = betterproto.string_field(1)
    cluster: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    last_updated: datetime = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RoutesConfigDump(betterproto.Message):
    static_route_configs: List[
        "RoutesConfigDumpStaticRouteConfig"
    ] = betterproto.message_field(2)
    dynamic_route_configs: List[
        "RoutesConfigDumpDynamicRouteConfig"
    ] = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RoutesConfigDumpStaticRouteConfig(betterproto.Message):
    route_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)
    last_updated: datetime = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RoutesConfigDumpDynamicRouteConfig(betterproto.Message):
    version_info: str = betterproto.string_field(1)
    route_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    last_updated: datetime = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ScopedRoutesConfigDump(betterproto.Message):
    inline_scoped_route_configs: List[
        "ScopedRoutesConfigDumpInlineScopedRouteConfigs"
    ] = betterproto.message_field(1)
    dynamic_scoped_route_configs: List[
        "ScopedRoutesConfigDumpDynamicScopedRouteConfigs"
    ] = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ScopedRoutesConfigDumpInlineScopedRouteConfigs(betterproto.Message):
    name: str = betterproto.string_field(1)
    scoped_route_configs: List[
        "betterproto_lib_google_protobuf.Any"
    ] = betterproto.message_field(2)
    last_updated: datetime = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ScopedRoutesConfigDumpDynamicScopedRouteConfigs(betterproto.Message):
    name: str = betterproto.string_field(1)
    version_info: str = betterproto.string_field(2)
    scoped_route_configs: List[
        "betterproto_lib_google_protobuf.Any"
    ] = betterproto.message_field(3)
    last_updated: datetime = betterproto.message_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SecretsConfigDump(betterproto.Message):
    static_secrets: List["SecretsConfigDumpStaticSecret"] = betterproto.message_field(1)
    dynamic_active_secrets: List[
        "SecretsConfigDumpDynamicSecret"
    ] = betterproto.message_field(2)
    dynamic_warming_secrets: List[
        "SecretsConfigDumpDynamicSecret"
    ] = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SecretsConfigDumpDynamicSecret(betterproto.Message):
    name: str = betterproto.string_field(1)
    version_info: str = betterproto.string_field(2)
    last_updated: datetime = betterproto.message_field(3)
    secret: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SecretsConfigDumpStaticSecret(betterproto.Message):
    name: str = betterproto.string_field(1)
    last_updated: datetime = betterproto.message_field(2)
    secret: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class EndpointsConfigDump(betterproto.Message):
    static_endpoint_configs: List[
        "EndpointsConfigDumpStaticEndpointConfig"
    ] = betterproto.message_field(2)
    dynamic_endpoint_configs: List[
        "EndpointsConfigDumpDynamicEndpointConfig"
    ] = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class EndpointsConfigDumpStaticEndpointConfig(betterproto.Message):
    endpoint_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        1
    )
    last_updated: datetime = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class EndpointsConfigDumpDynamicEndpointConfig(betterproto.Message):
    version_info: str = betterproto.string_field(1)
    endpoint_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        2
    )
    last_updated: datetime = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class TapRequest(betterproto.Message):
    """
    Proto representation of the statistics collected upon absl::Mutex
    contention, if Envoy is run under :option:`--enable-mutex-tracing`. For
    more information, see the `absl::Mutex`
    [docs](https://abseil.io/about/design/mutex#extra-features). *NB*: The wait
    cycles below are measured by `absl::base_internal::CycleClock`, and may not
    correspond to core clock frequency. For more information, see the
    `CycleClock` [docs](https://github.com/abseil/abseil-
    cpp/blob/master/absl/base/internal/cycleclock.h).
    """

    # The number of individual mutex contentions which have occurred since
    # startup.
    config_id: str = betterproto.string_field(1)
    # The length of the current contention wait cycle.
    tap_config: "__config_tap_v3__.TapConfig" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


from ...config.bootstrap import v3 as __config_bootstrap_v3__
from ...config.core import v3 as __config_core_v3__
from ...config.tap import v3 as __config_tap_v3__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
