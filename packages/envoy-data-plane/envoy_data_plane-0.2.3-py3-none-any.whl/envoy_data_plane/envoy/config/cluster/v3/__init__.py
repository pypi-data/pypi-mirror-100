# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/cluster/v3/circuit_breaker.proto, envoy/config/cluster/v3/filter.proto, envoy/config/cluster/v3/outlier_detection.proto, envoy/config/cluster/v3/cluster.proto
# plugin: python-betterproto
import warnings
from dataclasses import dataclass
from datetime import timedelta
from typing import Dict, List, Optional

import betterproto


class ClusterDiscoveryType(betterproto.Enum):
    STATIC = 0
    STRICT_DNS = 1
    LOGICAL_DNS = 2
    EDS = 3
    ORIGINAL_DST = 4


class ClusterLbPolicy(betterproto.Enum):
    ROUND_ROBIN = 0
    LEAST_REQUEST = 1
    RING_HASH = 2
    RANDOM = 3
    MAGLEV = 5
    CLUSTER_PROVIDED = 6
    LOAD_BALANCING_POLICY_CONFIG = 7


class ClusterDnsLookupFamily(betterproto.Enum):
    AUTO = 0
    V4_ONLY = 1
    V6_ONLY = 2


class ClusterClusterProtocolSelection(betterproto.Enum):
    USE_CONFIGURED_PROTOCOL = 0
    USE_DOWNSTREAM_PROTOCOL = 1


class ClusterLbSubsetConfigLbSubsetFallbackPolicy(betterproto.Enum):
    NO_FALLBACK = 0
    ANY_ENDPOINT = 1
    DEFAULT_SUBSET = 2


class ClusterLbSubsetConfigLbSubsetSelectorLbSubsetSelectorFallbackPolicy(
    betterproto.Enum
):
    NOT_DEFINED = 0
    NO_FALLBACK = 1
    ANY_ENDPOINT = 2
    DEFAULT_SUBSET = 3
    KEYS_SUBSET = 4


class ClusterRingHashLbConfigHashFunction(betterproto.Enum):
    XX_HASH = 0
    MURMUR_HASH_2 = 1


@dataclass(eq=False, repr=False)
class CircuitBreakers(betterproto.Message):
    """
    :ref:`Circuit breaking<arch_overview_circuit_break>` settings can be
    specified individually for each defined priority.
    """

    # If multiple :ref:`Thresholds<envoy_api_msg_config.cluster.v3.CircuitBreaker
    # s.Thresholds>` are defined with the same
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # first one in the list is used. If no Thresholds is defined for a given
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # default values are used.
    thresholds: List["CircuitBreakersThresholds"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CircuitBreakersThresholds(betterproto.Message):
    """
    A Thresholds defines CircuitBreaker settings for a
    :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`.
    [#next-free-field: 9]
    """

    # The :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`
    # the specified CircuitBreaker settings apply to.
    priority: "__core_v3__.RoutingPriority" = betterproto.enum_field(1)
    # The maximum number of connections that Envoy will make to the upstream
    # cluster. If not specified, the default is 1024.
    max_connections: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )
    # The maximum number of pending requests that Envoy will allow to the
    # upstream cluster. If not specified, the default is 1024.
    max_pending_requests: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_UINT32
    )
    # The maximum number of parallel requests that Envoy will make to the
    # upstream cluster. If not specified, the default is 1024.
    max_requests: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )
    # The maximum number of parallel retries that Envoy will allow to the
    # upstream cluster. If not specified, the default is 3.
    max_retries: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_UINT32
    )
    # Specifies a limit on concurrent retries in relation to the number of active
    # requests. This parameter is optional. .. note::    If this field is set,
    # the retry budget will override any configured retry circuit    breaker.
    retry_budget: "CircuitBreakersThresholdsRetryBudget" = betterproto.message_field(8)
    # If track_remaining is true, then stats will be published that expose the
    # number of resources remaining until the circuit breakers open. If not
    # specified, the default is false. .. note::    If a retry budget is used in
    # lieu of the max_retries circuit breaker,    the remaining retry resources
    # remaining will not be tracked.
    track_remaining: bool = betterproto.bool_field(6)
    # The maximum number of connection pools per cluster that Envoy will
    # concurrently support at once. If not specified, the default is unlimited.
    # Set this for clusters which create a large number of connection pools. See
    # :ref:`Circuit Breaking
    # <arch_overview_circuit_break_cluster_maximum_connection_pools>` for more
    # details.
    max_connection_pools: Optional[int] = betterproto.message_field(
        7, wraps=betterproto.TYPE_UINT32
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CircuitBreakersThresholdsRetryBudget(betterproto.Message):
    # Specifies the limit on concurrent retries as a percentage of the sum of
    # active requests and active pending requests. For example, if there are 100
    # active requests and the budget_percent is set to 25, there may be 25 active
    # retries. This parameter is optional. Defaults to 20%.
    budget_percent: "___type_v3__.Percent" = betterproto.message_field(1)
    # Specifies the minimum retry concurrency allowed for the retry budget. The
    # limit on the number of active retries may never go below this number. This
    # parameter is optional. Defaults to 3.
    min_retry_concurrency: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Filter(betterproto.Message):
    """
    :ref:`Circuit breaking<arch_overview_circuit_break>` settings can be
    specified individually for each defined priority.
    """

    # If multiple :ref:`Thresholds<envoy_api_msg_config.cluster.v3.CircuitBreaker
    # s.Thresholds>` are defined with the same
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # first one in the list is used. If no Thresholds is defined for a given
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # default values are used.
    name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class OutlierDetection(betterproto.Message):
    """
    :ref:`Circuit breaking<arch_overview_circuit_break>` settings can be
    specified individually for each defined priority.
    """

    # If multiple :ref:`Thresholds<envoy_api_msg_config.cluster.v3.CircuitBreaker
    # s.Thresholds>` are defined with the same
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # first one in the list is used. If no Thresholds is defined for a given
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # default values are used.
    consecutive_5_xx: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT32
    )
    interval: timedelta = betterproto.message_field(2)
    base_ejection_time: timedelta = betterproto.message_field(3)
    max_ejection_percent: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )
    enforcing_consecutive_5_xx: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_UINT32
    )
    enforcing_success_rate: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_UINT32
    )
    success_rate_minimum_hosts: Optional[int] = betterproto.message_field(
        7, wraps=betterproto.TYPE_UINT32
    )
    success_rate_request_volume: Optional[int] = betterproto.message_field(
        8, wraps=betterproto.TYPE_UINT32
    )
    success_rate_stdev_factor: Optional[int] = betterproto.message_field(
        9, wraps=betterproto.TYPE_UINT32
    )
    consecutive_gateway_failure: Optional[int] = betterproto.message_field(
        10, wraps=betterproto.TYPE_UINT32
    )
    enforcing_consecutive_gateway_failure: Optional[int] = betterproto.message_field(
        11, wraps=betterproto.TYPE_UINT32
    )
    split_external_local_origin_errors: bool = betterproto.bool_field(12)
    consecutive_local_origin_failure: Optional[int] = betterproto.message_field(
        13, wraps=betterproto.TYPE_UINT32
    )
    enforcing_consecutive_local_origin_failure: Optional[
        int
    ] = betterproto.message_field(14, wraps=betterproto.TYPE_UINT32)
    enforcing_local_origin_success_rate: Optional[int] = betterproto.message_field(
        15, wraps=betterproto.TYPE_UINT32
    )
    failure_percentage_threshold: Optional[int] = betterproto.message_field(
        16, wraps=betterproto.TYPE_UINT32
    )
    enforcing_failure_percentage: Optional[int] = betterproto.message_field(
        17, wraps=betterproto.TYPE_UINT32
    )
    enforcing_failure_percentage_local_origin: Optional[
        int
    ] = betterproto.message_field(18, wraps=betterproto.TYPE_UINT32)
    failure_percentage_minimum_hosts: Optional[int] = betterproto.message_field(
        19, wraps=betterproto.TYPE_UINT32
    )
    failure_percentage_request_volume: Optional[int] = betterproto.message_field(
        20, wraps=betterproto.TYPE_UINT32
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterCollection(betterproto.Message):
    """
    :ref:`Circuit breaking<arch_overview_circuit_break>` settings can be
    specified individually for each defined priority.
    """

    # If multiple :ref:`Thresholds<envoy_api_msg_config.cluster.v3.CircuitBreaker
    # s.Thresholds>` are defined with the same
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # first one in the list is used. If no Thresholds is defined for a given
    # :ref:`RoutingPriority<envoy_api_enum_config.core.v3.RoutingPriority>`, the
    # default values are used.
    entries: "____udpa_core_v1__.CollectionEntry" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Cluster(betterproto.Message):
    transport_socket_matches: List[
        "ClusterTransportSocketMatch"
    ] = betterproto.message_field(43)
    name: str = betterproto.string_field(1)
    alt_stat_name: str = betterproto.string_field(28)
    type: "ClusterDiscoveryType" = betterproto.enum_field(
        2, group="cluster_discovery_type"
    )
    cluster_type: "ClusterCustomClusterType" = betterproto.message_field(
        38, group="cluster_discovery_type"
    )
    eds_cluster_config: "ClusterEdsClusterConfig" = betterproto.message_field(3)
    connect_timeout: timedelta = betterproto.message_field(4)
    per_connection_buffer_limit_bytes: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_UINT32
    )
    lb_policy: "ClusterLbPolicy" = betterproto.enum_field(6)
    load_assignment: "__endpoint_v3__.ClusterLoadAssignment" = (
        betterproto.message_field(33)
    )
    health_checks: List["__core_v3__.HealthCheck"] = betterproto.message_field(8)
    max_requests_per_connection: Optional[int] = betterproto.message_field(
        9, wraps=betterproto.TYPE_UINT32
    )
    circuit_breakers: "CircuitBreakers" = betterproto.message_field(10)
    upstream_http_protocol_options: "__core_v3__.UpstreamHttpProtocolOptions" = (
        betterproto.message_field(46)
    )
    common_http_protocol_options: "__core_v3__.HttpProtocolOptions" = (
        betterproto.message_field(29)
    )
    http_protocol_options: "__core_v3__.Http1ProtocolOptions" = (
        betterproto.message_field(13)
    )
    http2_protocol_options: "__core_v3__.Http2ProtocolOptions" = (
        betterproto.message_field(14)
    )
    typed_extension_protocol_options: Dict[
        str, "betterproto_lib_google_protobuf.Any"
    ] = betterproto.map_field(36, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    dns_refresh_rate: timedelta = betterproto.message_field(16)
    dns_failure_refresh_rate: "ClusterRefreshRate" = betterproto.message_field(44)
    respect_dns_ttl: bool = betterproto.bool_field(39)
    dns_lookup_family: "ClusterDnsLookupFamily" = betterproto.enum_field(17)
    dns_resolvers: List["__core_v3__.Address"] = betterproto.message_field(18)
    use_tcp_for_dns_lookups: bool = betterproto.bool_field(45)
    outlier_detection: "OutlierDetection" = betterproto.message_field(19)
    cleanup_interval: timedelta = betterproto.message_field(20)
    upstream_bind_config: "__core_v3__.BindConfig" = betterproto.message_field(21)
    lb_subset_config: "ClusterLbSubsetConfig" = betterproto.message_field(22)
    ring_hash_lb_config: "ClusterRingHashLbConfig" = betterproto.message_field(
        23, group="lb_config"
    )
    maglev_lb_config: "ClusterMaglevLbConfig" = betterproto.message_field(
        52, group="lb_config"
    )
    original_dst_lb_config: "ClusterOriginalDstLbConfig" = betterproto.message_field(
        34, group="lb_config"
    )
    least_request_lb_config: "ClusterLeastRequestLbConfig" = betterproto.message_field(
        37, group="lb_config"
    )
    common_lb_config: "ClusterCommonLbConfig" = betterproto.message_field(27)
    transport_socket: "__core_v3__.TransportSocket" = betterproto.message_field(24)
    metadata: "__core_v3__.Metadata" = betterproto.message_field(25)
    protocol_selection: "ClusterClusterProtocolSelection" = betterproto.enum_field(26)
    upstream_connection_options: "UpstreamConnectionOptions" = (
        betterproto.message_field(30)
    )
    close_connections_on_host_health_failure: bool = betterproto.bool_field(31)
    ignore_health_on_host_removal: bool = betterproto.bool_field(32)
    filters: List["Filter"] = betterproto.message_field(40)
    load_balancing_policy: "LoadBalancingPolicy" = betterproto.message_field(41)
    lrs_server: "__core_v3__.ConfigSource" = betterproto.message_field(42)
    track_timeout_budgets: bool = betterproto.bool_field(47)
    upstream_config: "__core_v3__.TypedExtensionConfig" = betterproto.message_field(48)
    track_cluster_stats: "TrackClusterStats" = betterproto.message_field(49)
    prefetch_policy: "ClusterPrefetchPolicy" = betterproto.message_field(50)
    connection_pool_per_downstream_connection: bool = betterproto.bool_field(51)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.track_timeout_budgets:
            warnings.warn(
                "Cluster.track_timeout_budgets is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class ClusterTransportSocketMatch(betterproto.Message):
    name: str = betterproto.string_field(1)
    match: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(2)
    transport_socket: "__core_v3__.TransportSocket" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterCustomClusterType(betterproto.Message):
    name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterEdsClusterConfig(betterproto.Message):
    eds_config: "__core_v3__.ConfigSource" = betterproto.message_field(1)
    service_name: str = betterproto.string_field(2)
    eds_resource_locator: "____udpa_core_v1__.ResourceLocator" = (
        betterproto.message_field(3)
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterLbSubsetConfig(betterproto.Message):
    fallback_policy: "ClusterLbSubsetConfigLbSubsetFallbackPolicy" = (
        betterproto.enum_field(1)
    )
    default_subset: "betterproto_lib_google_protobuf.Struct" = (
        betterproto.message_field(2)
    )
    subset_selectors: List[
        "ClusterLbSubsetConfigLbSubsetSelector"
    ] = betterproto.message_field(3)
    locality_weight_aware: bool = betterproto.bool_field(4)
    scale_locality_weight: bool = betterproto.bool_field(5)
    panic_mode_any: bool = betterproto.bool_field(6)
    list_as_any: bool = betterproto.bool_field(7)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterLbSubsetConfigLbSubsetSelector(betterproto.Message):
    keys: List[str] = betterproto.string_field(1)
    single_host_per_subset: bool = betterproto.bool_field(4)
    fallback_policy: "ClusterLbSubsetConfigLbSubsetSelectorLbSubsetSelectorFallbackPolicy" = betterproto.enum_field(
        2
    )
    fallback_keys_subset: List[str] = betterproto.string_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterLeastRequestLbConfig(betterproto.Message):
    choice_count: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT32
    )
    active_request_bias: "__core_v3__.RuntimeDouble" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterRingHashLbConfig(betterproto.Message):
    minimum_ring_size: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT64
    )
    hash_function: "ClusterRingHashLbConfigHashFunction" = betterproto.enum_field(3)
    maximum_ring_size: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT64
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterMaglevLbConfig(betterproto.Message):
    table_size: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT64
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterOriginalDstLbConfig(betterproto.Message):
    use_http_header: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterCommonLbConfig(betterproto.Message):
    healthy_panic_threshold: "___type_v3__.Percent" = betterproto.message_field(1)
    zone_aware_lb_config: "ClusterCommonLbConfigZoneAwareLbConfig" = (
        betterproto.message_field(2, group="locality_config_specifier")
    )
    locality_weighted_lb_config: "ClusterCommonLbConfigLocalityWeightedLbConfig" = (
        betterproto.message_field(3, group="locality_config_specifier")
    )
    update_merge_window: timedelta = betterproto.message_field(4)
    ignore_new_hosts_until_first_hc: bool = betterproto.bool_field(5)
    close_connections_on_host_set_change: bool = betterproto.bool_field(6)
    consistent_hashing_lb_config: "ClusterCommonLbConfigConsistentHashingLbConfig" = (
        betterproto.message_field(7)
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterCommonLbConfigZoneAwareLbConfig(betterproto.Message):
    routing_enabled: "___type_v3__.Percent" = betterproto.message_field(1)
    min_cluster_size: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT64
    )
    fail_traffic_on_panic: bool = betterproto.bool_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterCommonLbConfigLocalityWeightedLbConfig(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterCommonLbConfigConsistentHashingLbConfig(betterproto.Message):
    use_hostname_for_hashing: bool = betterproto.bool_field(1)
    hash_balance_factor: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterRefreshRate(betterproto.Message):
    base_interval: timedelta = betterproto.message_field(1)
    max_interval: timedelta = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ClusterPrefetchPolicy(betterproto.Message):
    per_upstream_prefetch_ratio: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_DOUBLE
    )
    predictive_prefetch_ratio: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class LoadBalancingPolicy(betterproto.Message):
    policies: List["LoadBalancingPolicyPolicy"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class LoadBalancingPolicyPolicy(betterproto.Message):
    name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpstreamBindConfig(betterproto.Message):
    source_address: "__core_v3__.Address" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpstreamConnectionOptions(betterproto.Message):
    tcp_keepalive: "__core_v3__.TcpKeepalive" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class TrackClusterStats(betterproto.Message):
    timeout_budgets: bool = betterproto.bool_field(1)
    request_response_sizes: bool = betterproto.bool_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


from .....udpa.core import v1 as ____udpa_core_v1__
from ....type import v3 as ___type_v3__
from ...core import v3 as __core_v3__
from ...endpoint import v3 as __endpoint_v3__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
