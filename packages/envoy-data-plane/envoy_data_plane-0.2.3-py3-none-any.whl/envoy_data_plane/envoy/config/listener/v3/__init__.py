# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/listener/v3/api_listener.proto, envoy/config/listener/v3/listener_components.proto, envoy/config/listener/v3/udp_listener_config.proto, envoy/config/listener/v3/listener.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import List, Optional

import betterproto


class FilterChainMatchConnectionSourceType(betterproto.Enum):
    ANY = 0
    SAME_IP_OR_LOOPBACK = 1
    EXTERNAL = 2


class ListenerDrainType(betterproto.Enum):
    DEFAULT = 0
    MODIFY_ONLY = 1


@dataclass(eq=False, repr=False)
class ApiListener(betterproto.Message):
    """
    Describes a type of API listener, which is used in non-proxy clients. The
    type of API exposed to the non-proxy application depends on the type of API
    listener.
    """

    # The type in this field determines the type of API listener. At present, the
    # following types are supported: envoy.config.filter.network.http_connection_
    # manager.v2.HttpConnectionManager (HTTP) [#next-major-version: In the v3
    # API, replace this Any field with a oneof containing the specific config
    # message for each type of API listener. We could not do this in v2 because
    # it would have caused circular dependencies for go protos: lds.proto depends
    # on this file, and http_connection_manager.proto depends on rds.proto, which
    # is in the same directory as lds.proto, so lds.proto cannot depend on this
    # file.]
    api_listener: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Filter(betterproto.Message):
    """
    Describes a type of API listener, which is used in non-proxy clients. The
    type of API exposed to the non-proxy application depends on the type of API
    listener.
    """

    # The type in this field determines the type of API listener. At present, the
    # following types are supported: envoy.config.filter.network.http_connection_
    # manager.v2.HttpConnectionManager (HTTP) [#next-major-version: In the v3
    # API, replace this Any field with a oneof containing the specific config
    # message for each type of API listener. We could not do this in v2 because
    # it would have caused circular dependencies for go protos: lds.proto depends
    # on this file, and http_connection_manager.proto depends on rds.proto, which
    # is in the same directory as lds.proto, so lds.proto cannot depend on this
    # file.]
    name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        4, group="config_type"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class FilterChainMatch(betterproto.Message):
    destination_port: Optional[int] = betterproto.message_field(
        8, wraps=betterproto.TYPE_UINT32
    )
    prefix_ranges: List["__core_v3__.CidrRange"] = betterproto.message_field(3)
    address_suffix: str = betterproto.string_field(4)
    suffix_len: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_UINT32
    )
    source_type: "FilterChainMatchConnectionSourceType" = betterproto.enum_field(12)
    source_prefix_ranges: List["__core_v3__.CidrRange"] = betterproto.message_field(6)
    source_ports: List[int] = betterproto.uint32_field(7)
    server_names: List[str] = betterproto.string_field(11)
    transport_protocol: str = betterproto.string_field(9)
    application_protocols: List[str] = betterproto.string_field(10)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class FilterChain(betterproto.Message):
    filter_chain_match: "FilterChainMatch" = betterproto.message_field(1)
    filters: List["Filter"] = betterproto.message_field(3)
    use_proxy_proto: Optional[bool] = betterproto.message_field(
        4, wraps=betterproto.TYPE_BOOL
    )
    metadata: "__core_v3__.Metadata" = betterproto.message_field(5)
    transport_socket: "__core_v3__.TransportSocket" = betterproto.message_field(6)
    name: str = betterproto.string_field(7)
    on_demand_configuration: "FilterChainOnDemandConfiguration" = (
        betterproto.message_field(8)
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class FilterChainOnDemandConfiguration(betterproto.Message):
    rebuild_timeout: timedelta = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerFilterChainMatchPredicate(betterproto.Message):
    or_match: "ListenerFilterChainMatchPredicateMatchSet" = betterproto.message_field(
        1, group="rule"
    )
    and_match: "ListenerFilterChainMatchPredicateMatchSet" = betterproto.message_field(
        2, group="rule"
    )
    not_match: "ListenerFilterChainMatchPredicate" = betterproto.message_field(
        3, group="rule"
    )
    any_match: bool = betterproto.bool_field(4, group="rule")
    destination_port_range: "___type_v3__.Int32Range" = betterproto.message_field(
        5, group="rule"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerFilterChainMatchPredicateMatchSet(betterproto.Message):
    rules: List["ListenerFilterChainMatchPredicate"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerFilter(betterproto.Message):
    name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3, group="config_type"
    )
    filter_disabled: "ListenerFilterChainMatchPredicate" = betterproto.message_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UdpListenerConfig(betterproto.Message):
    """
    Describes a type of API listener, which is used in non-proxy clients. The
    type of API exposed to the non-proxy application depends on the type of API
    listener.
    """

    # The type in this field determines the type of API listener. At present, the
    # following types are supported: envoy.config.filter.network.http_connection_
    # manager.v2.HttpConnectionManager (HTTP) [#next-major-version: In the v3
    # API, replace this Any field with a oneof containing the specific config
    # message for each type of API listener. We could not do this in v2 because
    # it would have caused circular dependencies for go protos: lds.proto depends
    # on this file, and http_connection_manager.proto depends on rds.proto, which
    # is in the same directory as lds.proto, so lds.proto cannot depend on this
    # file.]
    udp_listener_name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3, group="config_type"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ActiveRawUdpListenerConfig(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerCollection(betterproto.Message):
    """
    Describes a type of API listener, which is used in non-proxy clients. The
    type of API exposed to the non-proxy application depends on the type of API
    listener.
    """

    # The type in this field determines the type of API listener. At present, the
    # following types are supported: envoy.config.filter.network.http_connection_
    # manager.v2.HttpConnectionManager (HTTP) [#next-major-version: In the v3
    # API, replace this Any field with a oneof containing the specific config
    # message for each type of API listener. We could not do this in v2 because
    # it would have caused circular dependencies for go protos: lds.proto depends
    # on this file, and http_connection_manager.proto depends on rds.proto, which
    # is in the same directory as lds.proto, so lds.proto cannot depend on this
    # file.]
    entries: List["____udpa_core_v1__.CollectionEntry"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Listener(betterproto.Message):
    name: str = betterproto.string_field(1)
    address: "__core_v3__.Address" = betterproto.message_field(2)
    filter_chains: List["FilterChain"] = betterproto.message_field(3)
    per_connection_buffer_limit_bytes: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_UINT32
    )
    metadata: "__core_v3__.Metadata" = betterproto.message_field(6)
    deprecated_v1: "ListenerDeprecatedV1" = betterproto.message_field(7)
    drain_type: "ListenerDrainType" = betterproto.enum_field(8)
    listener_filters: List["ListenerFilter"] = betterproto.message_field(9)
    listener_filters_timeout: timedelta = betterproto.message_field(15)
    continue_on_listener_filters_timeout: bool = betterproto.bool_field(17)
    transparent: Optional[bool] = betterproto.message_field(
        10, wraps=betterproto.TYPE_BOOL
    )
    freebind: Optional[bool] = betterproto.message_field(
        11, wraps=betterproto.TYPE_BOOL
    )
    socket_options: List["__core_v3__.SocketOption"] = betterproto.message_field(13)
    tcp_fast_open_queue_length: Optional[int] = betterproto.message_field(
        12, wraps=betterproto.TYPE_UINT32
    )
    traffic_direction: "__core_v3__.TrafficDirection" = betterproto.enum_field(16)
    udp_listener_config: "UdpListenerConfig" = betterproto.message_field(18)
    api_listener: "ApiListener" = betterproto.message_field(19)
    connection_balance_config: "ListenerConnectionBalanceConfig" = (
        betterproto.message_field(20)
    )
    reuse_port: bool = betterproto.bool_field(21)
    access_log: List["__accesslog_v3__.AccessLog"] = betterproto.message_field(22)
    udp_writer_config: "__core_v3__.TypedExtensionConfig" = betterproto.message_field(
        23
    )
    tcp_backlog_size: Optional[int] = betterproto.message_field(
        24, wraps=betterproto.TYPE_UINT32
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerDeprecatedV1(betterproto.Message):
    bind_to_port: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerConnectionBalanceConfig(betterproto.Message):
    exact_balance: "ListenerConnectionBalanceConfigExactBalance" = (
        betterproto.message_field(1, group="balance_type")
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerConnectionBalanceConfigExactBalance(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


from .....udpa.core import v1 as ____udpa_core_v1__
from ....type import v3 as ___type_v3__
from ...accesslog import v3 as __accesslog_v3__
from ...core import v3 as __core_v3__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
