# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/data/tap/v3/common.proto, envoy/data/tap/v3/http.proto, envoy/data/tap/v3/transport.proto, envoy/data/tap/v3/wrapper.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import List

import betterproto


@dataclass(eq=False, repr=False)
class Body(betterproto.Message):
    """
    Wrapper for tapped body data. This includes HTTP request/response body,
    transport socket received and transmitted data, etc.
    """

    # Body data as bytes. By default, tap body data will be present in this
    # field, as the proto `bytes` type can contain any valid byte.
    as_bytes: bytes = betterproto.bytes_field(1, group="body_type")
    # Body data as string. This field is only used when the
    # :ref:`JSON_BODY_AS_STRING
    # <envoy_api_enum_value_config.tap.v3.OutputSink.Format.JSON_BODY_AS_STRING>`
    # sink format type is selected. See the documentation for that option for why
    # this is useful.
    as_string: str = betterproto.string_field(2, group="body_type")
    # Specifies whether body data has been truncated to fit within the specified
    # :ref:`max_buffered_rx_bytes
    # <envoy_api_field_config.tap.v3.OutputConfig.max_buffered_rx_bytes>` and
    # :ref:`max_buffered_tx_bytes
    # <envoy_api_field_config.tap.v3.OutputConfig.max_buffered_tx_bytes>`
    # settings.
    truncated: bool = betterproto.bool_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class HttpBufferedTrace(betterproto.Message):
    """
    Wrapper for tapped body data. This includes HTTP request/response body,
    transport socket received and transmitted data, etc.
    """

    # Body data as bytes. By default, tap body data will be present in this
    # field, as the proto `bytes` type can contain any valid byte.
    request: "HttpBufferedTraceMessage" = betterproto.message_field(1)
    # Body data as string. This field is only used when the
    # :ref:`JSON_BODY_AS_STRING
    # <envoy_api_enum_value_config.tap.v3.OutputSink.Format.JSON_BODY_AS_STRING>`
    # sink format type is selected. See the documentation for that option for why
    # this is useful.
    response: "HttpBufferedTraceMessage" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class HttpBufferedTraceMessage(betterproto.Message):
    headers: List["___config_core_v3__.HeaderValue"] = betterproto.message_field(1)
    body: "Body" = betterproto.message_field(2)
    trailers: List["___config_core_v3__.HeaderValue"] = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class HttpStreamedTraceSegment(betterproto.Message):
    trace_id: int = betterproto.uint64_field(1)
    request_headers: "___config_core_v3__.HeaderMap" = betterproto.message_field(
        2, group="message_piece"
    )
    request_body_chunk: "Body" = betterproto.message_field(3, group="message_piece")
    request_trailers: "___config_core_v3__.HeaderMap" = betterproto.message_field(
        4, group="message_piece"
    )
    response_headers: "___config_core_v3__.HeaderMap" = betterproto.message_field(
        5, group="message_piece"
    )
    response_body_chunk: "Body" = betterproto.message_field(6, group="message_piece")
    response_trailers: "___config_core_v3__.HeaderMap" = betterproto.message_field(
        7, group="message_piece"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Connection(betterproto.Message):
    """
    Wrapper for tapped body data. This includes HTTP request/response body,
    transport socket received and transmitted data, etc.
    """

    # Body data as bytes. By default, tap body data will be present in this
    # field, as the proto `bytes` type can contain any valid byte.
    local_address: "___config_core_v3__.Address" = betterproto.message_field(2)
    # Body data as string. This field is only used when the
    # :ref:`JSON_BODY_AS_STRING
    # <envoy_api_enum_value_config.tap.v3.OutputSink.Format.JSON_BODY_AS_STRING>`
    # sink format type is selected. See the documentation for that option for why
    # this is useful.
    remote_address: "___config_core_v3__.Address" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SocketEvent(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    read: "SocketEventRead" = betterproto.message_field(2, group="event_selector")
    write: "SocketEventWrite" = betterproto.message_field(3, group="event_selector")
    closed: "SocketEventClosed" = betterproto.message_field(4, group="event_selector")

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SocketEventRead(betterproto.Message):
    data: "Body" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SocketEventWrite(betterproto.Message):
    data: "Body" = betterproto.message_field(1)
    end_stream: bool = betterproto.bool_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SocketEventClosed(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SocketBufferedTrace(betterproto.Message):
    trace_id: int = betterproto.uint64_field(1)
    connection: "Connection" = betterproto.message_field(2)
    events: List["SocketEvent"] = betterproto.message_field(3)
    read_truncated: bool = betterproto.bool_field(4)
    write_truncated: bool = betterproto.bool_field(5)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SocketStreamedTraceSegment(betterproto.Message):
    trace_id: int = betterproto.uint64_field(1)
    connection: "Connection" = betterproto.message_field(2, group="message_piece")
    event: "SocketEvent" = betterproto.message_field(3, group="message_piece")

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class TraceWrapper(betterproto.Message):
    """
    Wrapper for tapped body data. This includes HTTP request/response body,
    transport socket received and transmitted data, etc.
    """

    # Body data as bytes. By default, tap body data will be present in this
    # field, as the proto `bytes` type can contain any valid byte.
    http_buffered_trace: "HttpBufferedTrace" = betterproto.message_field(
        1, group="trace"
    )
    # Body data as string. This field is only used when the
    # :ref:`JSON_BODY_AS_STRING
    # <envoy_api_enum_value_config.tap.v3.OutputSink.Format.JSON_BODY_AS_STRING>`
    # sink format type is selected. See the documentation for that option for why
    # this is useful.
    http_streamed_trace_segment: "HttpStreamedTraceSegment" = betterproto.message_field(
        2, group="trace"
    )
    # Specifies whether body data has been truncated to fit within the specified
    # :ref:`max_buffered_rx_bytes
    # <envoy_api_field_config.tap.v3.OutputConfig.max_buffered_rx_bytes>` and
    # :ref:`max_buffered_tx_bytes
    # <envoy_api_field_config.tap.v3.OutputConfig.max_buffered_tx_bytes>`
    # settings.
    socket_buffered_trace: "SocketBufferedTrace" = betterproto.message_field(
        3, group="trace"
    )
    socket_streamed_trace_segment: "SocketStreamedTraceSegment" = (
        betterproto.message_field(4, group="trace")
    )

    def __post_init__(self) -> None:
        super().__post_init__()


from ....config.core import v3 as ___config_core_v3__
