# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/listener/v4alpha/udp_listener_config.proto, envoy/config/listener/v4alpha/udp_default_writer_config.proto, envoy/config/listener/v4alpha/udp_gso_batch_writer_config.proto, envoy/config/listener/v4alpha/api_listener.proto, envoy/config/listener/v4alpha/listener_components.proto, envoy/config/listener/v4alpha/listener.proto, envoy/config/listener/v4alpha/quic_config.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import List, Optional

import betterproto


class FilterChainMatchConnectionSourceType(betterproto.Enum):
    ANY = 0
    SAME_IP_OR_LOOPBACK = 1
    EXTERNAL = 2


class ListenerDrainType(betterproto.Enum):
    DEFAULT = 0
    MODIFY_ONLY = 1


@dataclass(eq=False, repr=False)
class UdpListenerConfig(betterproto.Message):
    # Used to look up UDP listener factory, matches "raw_udp_listener" or
    # "quic_listener" to create a specific udp listener. If not specified, treat
    # as "raw_udp_listener".
    udp_listener_name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3, group="config_type"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ActiveRawUdpListenerConfig(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UdpDefaultWriterOptions(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UdpGsoBatchWriterOptions(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ApiListener(betterproto.Message):
    # Used to look up UDP listener factory, matches "raw_udp_listener" or
    # "quic_listener" to create a specific udp listener. If not specified, treat
    # as "raw_udp_listener".
    api_listener: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Filter(betterproto.Message):
    # Used to look up UDP listener factory, matches "raw_udp_listener" or
    # "quic_listener" to create a specific udp listener. If not specified, treat
    # as "raw_udp_listener".
    name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        4, group="config_type"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class FilterChainMatch(betterproto.Message):
    destination_port: Optional[int] = betterproto.message_field(
        8, wraps=betterproto.TYPE_UINT32
    )
    prefix_ranges: List["__core_v4_alpha__.CidrRange"] = betterproto.message_field(3)
    address_suffix: str = betterproto.string_field(4)
    suffix_len: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_UINT32
    )
    source_type: "FilterChainMatchConnectionSourceType" = betterproto.enum_field(12)
    source_prefix_ranges: List[
        "__core_v4_alpha__.CidrRange"
    ] = betterproto.message_field(6)
    source_ports: List[int] = betterproto.uint32_field(7)
    server_names: List[str] = betterproto.string_field(11)
    transport_protocol: str = betterproto.string_field(9)
    application_protocols: List[str] = betterproto.string_field(10)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class FilterChain(betterproto.Message):
    filter_chain_match: "FilterChainMatch" = betterproto.message_field(1)
    filters: List["Filter"] = betterproto.message_field(3)
    use_proxy_proto: Optional[bool] = betterproto.message_field(
        4, wraps=betterproto.TYPE_BOOL
    )
    metadata: "__core_v4_alpha__.Metadata" = betterproto.message_field(5)
    transport_socket: "__core_v4_alpha__.TransportSocket" = betterproto.message_field(6)
    name: str = betterproto.string_field(7)
    on_demand_configuration: "FilterChainOnDemandConfiguration" = (
        betterproto.message_field(8)
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class FilterChainOnDemandConfiguration(betterproto.Message):
    rebuild_timeout: timedelta = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerFilterChainMatchPredicate(betterproto.Message):
    or_match: "ListenerFilterChainMatchPredicateMatchSet" = betterproto.message_field(
        1, group="rule"
    )
    and_match: "ListenerFilterChainMatchPredicateMatchSet" = betterproto.message_field(
        2, group="rule"
    )
    not_match: "ListenerFilterChainMatchPredicate" = betterproto.message_field(
        3, group="rule"
    )
    any_match: bool = betterproto.bool_field(4, group="rule")
    destination_port_range: "___type_v3__.Int32Range" = betterproto.message_field(
        5, group="rule"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerFilterChainMatchPredicateMatchSet(betterproto.Message):
    rules: List["ListenerFilterChainMatchPredicate"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerFilter(betterproto.Message):
    name: str = betterproto.string_field(1)
    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3, group="config_type"
    )
    filter_disabled: "ListenerFilterChainMatchPredicate" = betterproto.message_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerCollection(betterproto.Message):
    # Used to look up UDP listener factory, matches "raw_udp_listener" or
    # "quic_listener" to create a specific udp listener. If not specified, treat
    # as "raw_udp_listener".
    entries: List["____udpa_core_v1__.CollectionEntry"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class Listener(betterproto.Message):
    name: str = betterproto.string_field(1)
    address: "__core_v4_alpha__.Address" = betterproto.message_field(2)
    filter_chains: List["FilterChain"] = betterproto.message_field(3)
    per_connection_buffer_limit_bytes: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_UINT32
    )
    metadata: "__core_v4_alpha__.Metadata" = betterproto.message_field(6)
    deprecated_v1: "ListenerDeprecatedV1" = betterproto.message_field(7)
    drain_type: "ListenerDrainType" = betterproto.enum_field(8)
    listener_filters: List["ListenerFilter"] = betterproto.message_field(9)
    listener_filters_timeout: timedelta = betterproto.message_field(15)
    continue_on_listener_filters_timeout: bool = betterproto.bool_field(17)
    transparent: Optional[bool] = betterproto.message_field(
        10, wraps=betterproto.TYPE_BOOL
    )
    freebind: Optional[bool] = betterproto.message_field(
        11, wraps=betterproto.TYPE_BOOL
    )
    socket_options: List["__core_v4_alpha__.SocketOption"] = betterproto.message_field(
        13
    )
    tcp_fast_open_queue_length: Optional[int] = betterproto.message_field(
        12, wraps=betterproto.TYPE_UINT32
    )
    traffic_direction: "__core_v4_alpha__.TrafficDirection" = betterproto.enum_field(16)
    udp_listener_config: "UdpListenerConfig" = betterproto.message_field(18)
    api_listener: "ApiListener" = betterproto.message_field(19)
    connection_balance_config: "ListenerConnectionBalanceConfig" = (
        betterproto.message_field(20)
    )
    reuse_port: bool = betterproto.bool_field(21)
    access_log: List["__accesslog_v4_alpha__.AccessLog"] = betterproto.message_field(22)
    udp_writer_config: "__core_v4_alpha__.TypedExtensionConfig" = (
        betterproto.message_field(23)
    )
    tcp_backlog_size: Optional[int] = betterproto.message_field(
        24, wraps=betterproto.TYPE_UINT32
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerDeprecatedV1(betterproto.Message):
    bind_to_port: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerConnectionBalanceConfig(betterproto.Message):
    exact_balance: "ListenerConnectionBalanceConfigExactBalance" = (
        betterproto.message_field(1, group="balance_type")
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListenerConnectionBalanceConfigExactBalance(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class QuicProtocolOptions(betterproto.Message):
    # Used to look up UDP listener factory, matches "raw_udp_listener" or
    # "quic_listener" to create a specific udp listener. If not specified, treat
    # as "raw_udp_listener".
    max_concurrent_streams: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT32
    )
    idle_timeout: timedelta = betterproto.message_field(2)
    crypto_handshake_timeout: timedelta = betterproto.message_field(3)
    enabled: "__core_v4_alpha__.RuntimeFeatureFlag" = betterproto.message_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()


from .....udpa.core import v1 as ____udpa_core_v1__
from ....type import v3 as ___type_v3__
from ...accesslog import v4alpha as __accesslog_v4_alpha__
from ...core import v4alpha as __core_v4_alpha__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
